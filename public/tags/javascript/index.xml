<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on Today I learned</title>
    <link>/tags/javascript/</link>
    <description>Recent content in Javascript on Today I learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright (c) 2018, all rights reserved.</copyright>
    <lastBuildDate>Thu, 13 Dec 2018 22:04:51 +0530</lastBuildDate>
    
	<atom:link href="/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>React Hooks</title>
      <link>/post/react-hooks/</link>
      <pubDate>Thu, 13 Dec 2018 22:04:51 +0530</pubDate>
      
      <guid>/post/react-hooks/</guid>
      <description>React Hooks Lets you use state and other React features without writing a class.
 import { useState } from &#39;react&#39;; function Example() { // Declare a new state variable, which we&#39;ll call &amp;quot;count&amp;quot; const [count, setCount] = useState(0); return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;You clicked {count} times&amp;lt;/p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt; Click me &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ); }  In React class components, side-effects were mostly introduced in lifecycle methods (e.</description>
    </item>
    
    <item>
      <title>React Hooks</title>
      <link>/post/react-js/</link>
      <pubDate>Thu, 13 Dec 2018 22:04:51 +0530</pubDate>
      
      <guid>/post/react-js/</guid>
      <description> Basics Components splits the UI into independent, reusable pieces, and think about each piece in isolation.
 function Welcome(props) { return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;; } // OR class Welcome extends React.Component { render() { return &amp;lt;h1&amp;gt;Hello, {this.props.name}&amp;lt;/h1&amp;gt;; } }  Rendering
function Welcome(props) { return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;; } const element = &amp;lt;Welcome name=&amp;quot;Sara&amp;quot; /&amp;gt;; ReactDOM.render( element, document.getElementById(&#39;root&#39;) );  </description>
    </item>
    
    <item>
      <title>Javascript II</title>
      <link>/post/javascript-ii/</link>
      <pubDate>Mon, 10 Dec 2018 14:44:59 +0530</pubDate>
      
      <guid>/post/javascript-ii/</guid>
      <description>Array methods forEach()  const arr = [1, 2, 3, 4, 5, 6]; arr.forEach(item =&amp;gt; { console.log(item); // output: 1 2 3 4 5 6 });  ## includes()
This method check if array includes the item passed in the method.
 const arr = [1, 2, 3, 4, 5, 6]; arr.includes(2); // output: true arr.includes(7); // output: false  filter() This method create new array with only elements passed condition inside the provided function.</description>
    </item>
    
    <item>
      <title>Promises and Generators</title>
      <link>/post/promises-generators/</link>
      <pubDate>Fri, 30 Nov 2018 21:49:43 +0530</pubDate>
      
      <guid>/post/promises-generators/</guid>
      <description>Promises  A proxy for a value not necessarily known when the promise is created.
An asynchronous function is a function which operates asynchronously via the event loop, using an implicit Promise to return its result.
then() consumes a Promise while await waits for a promise to be resolved
 Once a promise has been called, it will start in pending state. This means that the caller function continues the execution, while it waits for the promise to do its own processing, and give the caller function some feedback.</description>
    </item>
    
    <item>
      <title>Map Reduce and Filter</title>
      <link>/post/mapreducefilter/</link>
      <pubDate>Thu, 15 Nov 2018 21:24:18 +0530</pubDate>
      
      <guid>/post/mapreducefilter/</guid>
      <description>Map Reduce and Filter .map() To modify an array or it&amp;rsquo;s objects
map receives a callback as an argument. That callback is then given the current value of the iteration, the index of the iteration and the original array from which map was called
const arr = [1,2,3,4,5]; const newArray = arr.map(i =&amp;gt; i*10); // return a new array with all value as multiple of 10;  var officers = [ { id: 20, name: &#39;Captain Piett&#39; }, { id: 24, name: &#39;General Veers&#39; }, { id: 56, name: &#39;Admiral Ozzel&#39; }, { id: 88, name: &#39;Commander Jerjerrod&#39; } ]; var officersIds = officers.</description>
    </item>
    
    <item>
      <title>Redux 1</title>
      <link>/post/redux-1/</link>
      <pubDate>Mon, 01 Oct 2018 21:39:04 +0530</pubDate>
      
      <guid>/post/redux-1/</guid>
      <description>Redux is a predictable state container for JavaScript apps. import { createStore } from &amp;quot;redux&amp;quot;; //an import from the redux library const store = createStore(); // Takes reducer as argument  Store stores the states and reducers handles the communication
Reducers modifies the state based on action in pure state
In redux, all application state exists as a single store object
Spread operator or splat operator copies the contents of one array object into another.</description>
    </item>
    
    <item>
      <title>Javascript</title>
      <link>/post/javascript/</link>
      <pubDate>Sun, 22 Jul 2018 13:50:50 +0530</pubDate>
      
      <guid>/post/javascript/</guid>
      <description>Callback functions They are derived from a programming paradigm known as functional programmings
A callback function, also known as a higher-order function, is a function that is passed to another function Eg:
 $(&amp;quot;#btn_1&amp;quot;).click(function() { alert(&amp;quot;Btn 1 Clicked&amp;quot;); });  Functional programming (often abbreviated FP) is the process of building software by composing pure functions, avoiding shared state, mutable data, and side-effects
A pure function is a function which: Given the same inputs, always returns the same output, and Has no side-effects</description>
    </item>
    
  </channel>
</rss>